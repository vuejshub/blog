import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as a,o as n}from"./app-BrKqmITf.js";const t={};function r(l,i){return n(),s("div",null,[...i[0]||(i[0]=[a(`<h1 id="typescript-中interface和type的区别" tabindex="-1"><a class="header-anchor" href="#typescript-中interface和type的区别"><span>TypeScript 中interface和type的区别</span></a></h1><p>在 TypeScript 中，<code>interface</code> 和 <code>type</code> 都用于定义对象的形状（shape）或类型，但它们之间存在一些关键的区别和适用场景。了解这些区别有助于你根据具体需求选择最合适的工具。</p><h3 id="_1-声明合并-declaration-merging" tabindex="-1"><a class="header-anchor" href="#_1-声明合并-declaration-merging"><span><strong>1. 声明合并（Declaration Merging）</strong></span></a></h3><ul><li><strong>Interface</strong>：支持声明合并。如果你定义了两个相同名称的接口，TypeScript 会将它们合并成一个接口。这在你需要扩展一个库中的接口时非常有用。</li><li><strong>Type</strong>：不支持声明合并。如果你尝试定义两个相同名称的类型别名，TypeScript 会报错，因为它认为这是一个重复的定义。</li></ul><h3 id="_2-索引签名-index-signatures" tabindex="-1"><a class="header-anchor" href="#_2-索引签名-index-signatures"><span><strong>2. 索引签名（Index Signatures）</strong></span></a></h3><ul><li><strong>Interface</strong> 和 <strong>Type</strong> 都支持索引签名，允许你定义一个对象可以拥有的键的类型，以及这些键对应的值的类型。</li></ul><h3 id="_3-映射类型-mapped-types" tabindex="-1"><a class="header-anchor" href="#_3-映射类型-mapped-types"><span><strong>3. 映射类型（Mapped Types）</strong></span></a></h3><ul><li><strong>Type</strong>：支持映射类型，这是一种高级类型，允许你基于另一个类型来创建新类型。例如，你可以创建一个新类型，其属性是原类型属性名的字符串版本。</li><li><strong>Interface</strong>：不支持映射类型。</li></ul><h3 id="_4-继承-inheritance" tabindex="-1"><a class="header-anchor" href="#_4-继承-inheritance"><span><strong>4. 继承（Inheritance）</strong></span></a></h3><ul><li><strong>Interface</strong>：支持继承，一个接口可以继承一个或多个其他接口，从而组合多个接口的功能。</li><li><strong>Type</strong>：虽然类型别名本身不支持继承，但你可以通过交叉类型（Intersection Types）来模拟继承的效果，即合并多个类型。</li></ul><h3 id="_5-泛型-generics" tabindex="-1"><a class="header-anchor" href="#_5-泛型-generics"><span><strong>5. 泛型（Generics）</strong></span></a></h3><ul><li><strong>Interface</strong> 和 <strong>Type</strong> 都支持泛型，允许你定义灵活的组件，这些组件可以工作于多种类型的数据上。</li></ul><h3 id="_6-可用性" tabindex="-1"><a class="header-anchor" href="#_6-可用性"><span><strong>6. 可用性</strong></span></a></h3><ul><li><strong>Interface</strong>：更适合定义对象的形状，特别是当你想利用声明合并或继承时。</li><li><strong>Type</strong>：更灵活，支持更复杂的类型操作，如映射类型、条件类型等。当你需要定义一些复杂的类型逻辑时，类型别名可能更合适。</li></ul><h3 id="_7-示例" tabindex="-1"><a class="header-anchor" href="#_7-示例"><span><strong>7. 示例</strong></span></a></h3><p><strong>Interface 示例</strong>：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> User</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    name</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    age</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Admin</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> User</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    role</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;admin&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Type 示例</strong>（使用交叉类型模拟继承）：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> User</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    name</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    age</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> number</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Admin</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> User</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    role</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;admin&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span><strong>结论</strong></span></a></h3><p>选择 <code>interface</code> 还是 <code>type</code> 取决于你的具体需求。如果你需要利用声明合并或继承，或者你的类型定义相对简单，那么 <code>interface</code> 可能是一个更好的选择。如果你需要更复杂的类型操作，如映射类型或条件类型，或者你想避免命名冲突，那么 <code>type</code> 可能更适合你。在实际开发中，这两种方式经常一起使用，以充分利用它们各自的优势。</p>`,21)])])}const c=e(t,[["render",r]]),d=JSON.parse('{"path":"/typeScript/interfacevstype.html","title":"TypeScript 中interface和type的区别","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2022-01-09T00:00:00.000Z","category":["TypeScript"],"tag":["TypeScript"],"star":true,"sticky":true,"description":"TypeScript 中interface和type的区别 在 TypeScript 中，interface 和 type 都用于定义对象的形状（shape）或类型，但它们之间存在一些关键的区别和适用场景。了解这些区别有助于你根据具体需求选择最合适的工具。 1. 声明合并（Declaration Merging） Interface：支持声明合并。如果...","head":[["meta",{"property":"og:url","content":"https://vuejshub.github.io/blog/blog/typeScript/interfacevstype.html"}],["meta",{"property":"og:site_name","content":"前端进阶"}],["meta",{"property":"og:title","content":"TypeScript 中interface和type的区别"}],["meta",{"property":"og:description","content":"TypeScript 中interface和type的区别 在 TypeScript 中，interface 和 type 都用于定义对象的形状（shape）或类型，但它们之间存在一些关键的区别和适用场景。了解这些区别有助于你根据具体需求选择最合适的工具。 1. 声明合并（Declaration Merging） Interface：支持声明合并。如果..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-04T08:14:32.000Z"}],["meta",{"property":"article:tag","content":"TypeScript"}],["meta",{"property":"article:published_time","content":"2022-01-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-04T08:14:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TypeScript 中interface和type的区别\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-09T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-04T08:14:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Tim\\",\\"url\\":\\"https://vuejshub.github.io/blog/\\"}]}"]]},"headers":[{"level":3,"title":"1. 声明合并（Declaration Merging）","slug":"_1-声明合并-declaration-merging","link":"#_1-声明合并-declaration-merging","children":[]},{"level":3,"title":"2. 索引签名（Index Signatures）","slug":"_2-索引签名-index-signatures","link":"#_2-索引签名-index-signatures","children":[]},{"level":3,"title":"3. 映射类型（Mapped Types）","slug":"_3-映射类型-mapped-types","link":"#_3-映射类型-mapped-types","children":[]},{"level":3,"title":"4. 继承（Inheritance）","slug":"_4-继承-inheritance","link":"#_4-继承-inheritance","children":[]},{"level":3,"title":"5. 泛型（Generics）","slug":"_5-泛型-generics","link":"#_5-泛型-generics","children":[]},{"level":3,"title":"6. 可用性","slug":"_6-可用性","link":"#_6-可用性","children":[]},{"level":3,"title":"7. 示例","slug":"_7-示例","link":"#_7-示例","children":[]},{"level":3,"title":"结论","slug":"结论","link":"#结论","children":[]}],"git":{"createdTime":1730708072000,"updatedTime":1730708072000,"contributors":[{"name":"Tim","email":"qiaojiazhou@outlook.com","commits":1}]},"readingTime":{"minutes":2.27,"words":680},"filePathRelative":"typeScript/interfacevstype.md","localizedDate":"2022年1月9日","excerpt":"\\n<p>在 TypeScript 中，<code>interface</code>&nbsp;和&nbsp;<code>type</code>&nbsp;都用于定义对象的形状（shape）或类型，但它们之间存在一些关键的区别和适用场景。了解这些区别有助于你根据具体需求选择最合适的工具。</p>\\n<h3><strong>1. 声明合并（Declaration Merging）</strong></h3>\\n<ul>\\n<li><strong>Interface</strong>：支持声明合并。如果你定义了两个相同名称的接口，TypeScript 会将它们合并成一个接口。这在你需要扩展一个库中的接口时非常有用。</li>\\n<li><strong>Type</strong>：不支持声明合并。如果你尝试定义两个相同名称的类型别名，TypeScript 会报错，因为它认为这是一个重复的定义。</li>\\n</ul>","autoDesc":true}');export{c as comp,d as data};
